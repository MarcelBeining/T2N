proc init() {
	realtime = 0

	dtsav = dt						// Save desired dt value to reset after temporarily changing dt
	secondordersav = secondorder	// Save desired secondorder value to reset after temporarily changing secondorder

	finitialize(v_init)	// Call finitialize (since we are replacing the default init proc that calls this)
						// finitialize will Call the INITIAL block for all mechanisms and point processes inserted in the sections
						//	and set the initial voltage to v_init for all sections

	if (prerun>0) {
		t = - prerun -100			// Set the start time for (pre) simulation; -500 to prepare network in advance of start at 0
		dt= 10				// Set dt to large value
		secondorder = 0		// Set secondorder to 0 to set the default fully implicit backward euler for numerical integration (see NEURON ref)
		
		temp= cvode.active()
		if (temp!=0) {cvode.active(0)}	// If cvode is on, turn off temporarily to do large fixed step
		
		// Now, do a large pre run to set the network 'settle' and all components to reach steady state
		while(t<-10) { fadvance() 
		}
		
		if (temp!=0) {cvode.active(1)}	// If cvode was on and then turned off, turn it back on now
		dt = dtsav						// Reset dt to specified value
		t = tstart-dt						// Start time of the simulation (-dt to account for recording vectors at time 0)
		frecord_init()				// places the correct values into the recording vectors
		secondorder = secondordersav	// Reset secondorder to specified value
		
		if (cvode.active()){
			cvode.re_init()				// If cvode is active, initialize the integrator
			print "cvode reinit"
		} else {
			fcurrent()					// If cvode is not active, make all assigned variables (currents, conductances, etc) consistent with the values of the states
		}
	}
}

proc run() {
	running_ = 1
	continuerun(tstop)
}


proc totalarea() { local sum
  finitialize()
  sum = 0
//  forall for (x,0) sum += area(x)
  forsec $o1.allreg for (x,0) sum += area(x)
  print "total surface area = ", sum, " um2"
}



proc set_range() {
	f = new File()
	io = f.ropen($s2)
	io = thissec.scanf(f)
	io = f.close()
	f = new File()
	io = f.ropen($s3)
	io = thisseg.scanf(f)
	io = f.close()
	f = new File()
	io = f.ropen($s4)
	io = thisval.scanf(f)
	
	io = f.close()
	if (thissec.size()==thisseg.size() && thissec.size() == thisval.size()) {
		for c = 0, thissec.size()-1 {
			io = sprint(tmpstr,"%s(thisseg.x(c)) = thisval.x(c)",$s5)
			cellList.o($1).allregobj.o(thissec.x(c)).sec     io = execute(tmpstr)
			//print $1, thissec.x(c), thisseg.x(c), thisval.x(c)
		}
		thissec.resize(0)
		thisseg.resize(0)
		thisval.resize(0)
	}else {execerror("Error, thisseg, thissec and thisval do not have same size! please check!!")}
}

// reads in the custom time vectors
proc read_tvecs() {strdef filnam
	sprint(filnam,"../%s/tvecs.dat",$s1) // simulation folder where tvecs.dat is stored
	f = new File()
	io = f.ropen(filnam)
	if (io!=0) {
		while (!f.eof()) {
			objref tmpvec
			tmpvec = new Vector(20000)
			io = tmpvec.scantil(f, -1e15)
			tvecs.append(tmpvec)
		}
		io = f.close()
	}
}

proc save_rec() {local n strdef filnam
	
	sprint(filnam,"%s/%s",simfold,$s1)   // simulation folder plus output file name
	
	if ($3 >0) {
		//if (cvode.active() && cvode.use_local_dt()) {
			print $s1
			io = sscanf($s1,"_cell%i_", &n)  // get the cell number of that recording (as different time vectors might exist for different cells
			tvec = rectList.o(int(n))
		//}
		print "test"
		if ($3 == 1) {
			// downsample vector to values of Dt
			tmpvec = new Vector(int(tvec.x[tvec.size()-1]/$4))
			tmpvec.indgen($4)
		}else{if ($3 == 2) {
			// downsample vector to values of tvec $4
			tmpvec = tvecs.o($4)
			}
		}
		// get the tvec indices of the desired times (or the closest to it) 
		for x = 0, tmpvec.size()-1 {
			tmpvec.x[x] = tvec.indwhere(">",tmpvec.x[x]) - 1
		}
		tmpvec = recList.o($2).ind(tmpvec) // resample the vector to only those positions
		// replace the recorded vector in the list with the new vector
		io = recList.insrt($2,tmpvec)
		io = recList.remove($2+1)
	}
	f = new File()
	io = f.wopen(filnam)
	io = recList.o($2).printf(f, "%-20.20g\n")
	io = f.close()
}

proc save_rect() {strdef filnam
	sprint(filnam,"%s/%s",simfold,$s1)

	f = new File()
	io = f.wopen(filnam)
	io = rectList.o($2).printf(f, "%-20.20g\n")
	io = f.close()
}


proc set_gid2node() {//strdef filnam
	// function to read in the host id for each gid that should be set
	sprint(filnam,"%s/gid2node.dat",simfold)
	f = new File()
	io = f.ropen(filnam)
	io = thisval.scanf(f)
	io = f.close()
	for c = 0, thisval.size()-1 {
		pc.set_gid2node(c,thisval.x(c)) // set gid for each node according to read vector
	}
	thisval.resize(0)
}

proc reg_cell() {
if (pc.gid_exists($1)) {
	if (cellList.o($2).is_artificial == 0) {
		io = sprint(tmpstr,"cellList.o(%d).allregobj.o(%d).sec {con = new NetCon(&%s(0.5),nil)}",$2,$3,$s4)
		io = execute(tmpstr)
	}else{
		con = new NetCon(cellList.o($2).cell,nil)
	}
	if (numarg()>4){con.threshold = $5}
	pc.cell($1,con)
	objref con
}
}

proc con_cellP() {
	con = pc.gid_connect($1,$o2)
	if (numarg()>2){con.delay = $3}
	if (numarg()>3){con.weight = $4}
	io = conList.append(con)
	objref con

}